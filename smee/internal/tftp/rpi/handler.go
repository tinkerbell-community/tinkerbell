package rpi

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/go-logr/logr"
	"github.com/tinkerbell/tinkerbell/smee/internal/dhcp"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

// rpiPathPattern matches Raspberry Pi TFTP paths like:
// - <serial>/<filename>
// - <mac-with-dashes>/<filename>
// Examples: b827eb123456/config.txt, b8-27-eb-12-34-56/config.txt
var rpiPathPattern = regexp.MustCompile(`^([0-9a-fA-F]{8,12}|[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2})/(.+)$`)

// Handler holds the configuration needed for Raspberry Pi boot file serving.
type Handler struct {
	Logger   logr.Logger
	CacheDir string
}

// TemplateData holds the data used to render Raspberry Pi config templates.
type TemplateData struct {
	MACAddress   net.HardwareAddr
	SerialNumber string
	KernelArgs   []string
	KernelImage  string
	InitrdImage  string
	// Additional fields can be added as needed
}

// ConfigTemplates maps filename patterns to their template content.
var ConfigTemplates = map[string]string{
	"config.txt": `# Raspberry Pi Config - {{ .MACAddress }}
# Auto-generated by Tinkerbell

# Device Tree and Boot Configuration
dtparam=audio=on
gpu_mem=64

# Kernel Configuration
kernel={{ if .KernelImage }}{{ .KernelImage }}{{ else }}kernel8.img{{ end }}
{{- if .InitrdImage }}
initramfs {{ .InitrdImage }} followkernel
{{- end }}

# Enable UART for console
enable_uart=1
`,
	"cmdline.txt": `console=serial0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait{{- range .KernelArgs }} {{ . }}{{- end }}`,
}

// ServeTFTP implements the TFTP handler interface for Raspberry Pi boot files.
func (h Handler) ServeTFTP(filename string, rf io.ReaderFrom) error {
	log := h.Logger.WithValues("event", "rpi_file", "filename", filename)
	log.Info("handling Raspberry Pi file request")

	// Check if cache directory is configured
	if h.CacheDir == "" {
		return fmt.Errorf("cache directory not configured")
	}

	// Create tracing context
	tracer := otel.Tracer("TFTP-RaspberryPi")
	_, span := tracer.Start(context.Background(), "TFTP Raspberry Pi file serve",
		trace.WithSpanKind(trace.SpanKindServer))
	defer span.End()

	// Parse the path to extract MAC/serial and actual filename
	matches := rpiPathPattern.FindStringSubmatch(filename)
	if len(matches) < 3 {
		err := fmt.Errorf("invalid Raspberry Pi path format: %s", filename)
		span.SetStatus(codes.Error, err.Error())
		return err
	}

	identifier := matches[1]
	actualFilename := matches[2]

	span.SetAttributes(
		attribute.String("rpi.identifier", identifier),
		attribute.String("rpi.filename", actualFilename),
	)

	// Extract MAC address if possible
	mac, err := extractMAC(identifier)
	if err != nil {
		log.V(1).Info("could not extract MAC from identifier, continuing anyway", "identifier", identifier, "error", err)
	} else {
		// Verify it's actually a Raspberry Pi
		if !dhcp.IsRaspberryPI(mac) {
			log.Info("MAC address does not match Raspberry Pi OUI", "mac", mac.String())
			// Continue anyway - serial number might be used instead
		} else {
			log.Info("verified Raspberry Pi device", "mac", mac.String())
			span.SetAttributes(
				attribute.String("rpi.mac", mac.String()),
				attribute.Bool("rpi.verified", true),
			)
		}
	}

	// Check if this is a templated config file
	if tmpl, isTemplate := ConfigTemplates[strings.ToLower(actualFilename)]; isTemplate {
		log.Info("serving templated config file", "filename", actualFilename)
		return h.serveTemplate(actualFilename, tmpl, mac, identifier, rf, span, log)
	}

	// Otherwise, serve as raw file from cache directory
	log.Info("serving raw file from cache", "filename", filename)
	return h.serveRawFile(filename, rf, span, log)
}

// serveTemplate renders and serves a templated configuration file.
func (h Handler) serveTemplate(filename, tmplContent string, mac net.HardwareAddr, serial string, rf io.ReaderFrom, span trace.Span, log logr.Logger) error {
	// Parse template
	tmpl, err := template.New(filename).Parse(tmplContent)
	if err != nil {
		err := fmt.Errorf("failed to parse template for %s: %w", filename, err)
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return err
	}

	// TODO: This could be enhanced to fetch data from backend based on MAC
	// For now, use defaults
	data := TemplateData{
		MACAddress:   mac,
		SerialNumber: serial,
		KernelArgs:   []string{"tinkerbell=1"},
		KernelImage:  "kernel8.img",
		InitrdImage:  "",
	}

	// Render template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		err := fmt.Errorf("failed to execute template for %s: %w", filename, err)
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return err
	}

	// Set size if supported
	if transfer, ok := rf.(interface{ SetSize(int64) }); ok {
		transfer.SetSize(int64(buf.Len()))
	}

	// Serve the rendered content
	n, err := rf.ReadFrom(&buf)
	if err != nil {
		log.Error(err, "failed to serve templated content")
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return fmt.Errorf("failed to serve templated content: %w", err)
	}

	log.Info("successfully served templated file", "filename", filename, "bytes_transferred", n)
	if span != nil {
		span.SetStatus(codes.Ok, "templated file served successfully")
	}
	return nil
}

// serveRawFile serves a raw file from the cache directory.
func (h Handler) serveRawFile(filename string, rf io.ReaderFrom, span trace.Span, log logr.Logger) error {
	// Construct the full file path
	filePath := filepath.Join(h.CacheDir, filename)

	// Security check - ensure the file is within the configured directory
	if !strings.HasPrefix(filepath.Clean(filePath), filepath.Clean(h.CacheDir)) {
		err := fmt.Errorf("invalid file path: %s", filename)
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return err
	}

	// Open the file for reading
	file, err := os.Open(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			err := fmt.Errorf("Raspberry Pi file not found: %s", filename)
			if span != nil {
				span.SetStatus(codes.Error, err.Error())
			}
			return err
		}
		log.Error(err, "failed to open Raspberry Pi file from filesystem")
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return fmt.Errorf("failed to open Raspberry Pi file from filesystem: %w", err)
	}
	defer file.Close()

	fi, err := file.Stat()
	if err != nil {
		log.Error(err, "failed to stat Raspberry Pi file")
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return fmt.Errorf("failed to stat Raspberry Pi file: %w", err)
	}

	if transfer, ok := rf.(interface{ SetSize(int64) }); ok {
		transfer.SetSize(fi.Size())
	}

	// Stream the file directly using ReadFrom
	n, err := rf.ReadFrom(file)
	if err != nil {
		log.Error(err, "failed to serve Raspberry Pi file content")
		if span != nil {
			span.SetStatus(codes.Error, err.Error())
		}
		return fmt.Errorf("failed to serve Raspberry Pi file content: %w", err)
	}

	log.Info("successfully served Raspberry Pi file", "filename", filename, "bytes_transferred", n)
	if span != nil {
		span.SetStatus(codes.Ok, "file served successfully")
	}
	return nil
}

// extractMAC attempts to extract a MAC address from the identifier.
// It handles both serial number format (8-12 hex chars) and MAC format (with dashes).
func extractMAC(identifier string) (net.HardwareAddr, error) {
	// Check if it's already in MAC format with dashes
	if strings.Contains(identifier, "-") {
		// Convert dashes to colons for standard MAC format
		macStr := strings.ReplaceAll(identifier, "-", ":")
		return net.ParseMAC(macStr)
	}

	// If it's a serial number (8-12 hex chars), it might be truncated MAC
	// Raspberry Pi serial numbers often use the last 6 bytes of MAC
	if len(identifier) >= 6 {
		// Take the last 6 hex pairs and insert colons
		// For a serial like "b827eb123456", extract MAC as "b8:27:eb:12:34:56"
		var macParts []string
		for i := 0; i < len(identifier) && i < 12; i += 2 {
			if i+2 <= len(identifier) {
				macParts = append(macParts, identifier[i:i+2])
			}
		}
		if len(macParts) == 6 {
			macStr := strings.Join(macParts, ":")
			return net.ParseMAC(macStr)
		}
	}

	return nil, fmt.Errorf("could not parse MAC from identifier: %s", identifier)
}
