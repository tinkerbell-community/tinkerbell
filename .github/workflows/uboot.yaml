name: U-Boot for Raspberry Pi Build

on:
  workflow_dispatch:
    inputs:
      uboot_version:
        description: "U-Boot version tag to build"
        required: false
        default: "v2025.10"
        type: string
      rpi_firmware_version:
        description: "Raspberry Pi firmware version"
        required: false
        default: "1.20241008"
        type: string
  push:
    tags:
      - 'uboot-v*'

env:
  UBOOT_VERSION: ${{ inputs.uboot_version || 'v2025.10' }}
  UBOOT_DIR: ${{ github.workspace }}/u-boot
  RPI_FIRMWARE_VERSION: ${{ inputs.rpi_firmware_version || '1.20241008' }}
  BUILD_DIR: ${{ github.workspace }}/build

jobs:
  build-uboot-image:
    runs-on: ubuntu-24.04-arm
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout u-boot
        uses: actions/checkout@v4
        with:
          repository: u-boot/u-boot
          fetch-depth: 1
          path: u-boot
          ref: ${{ env.UBOOT_VERSION }}

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            git \
            python3 \
            python3-setuptools \
            bison \
            flex \
            bc \
            libssl-dev \
            libgnutls28-dev \
            libgcrypt20-dev \
            zlib1g-dev \
            libcurl4-openssl-dev \
            gcc-aarch64-linux-gnu \
            device-tree-compiler \
            dosfstools \
            mtools \
            parted \
            wget \
            xz-utils

      - name: Configure U-Boot for Raspberry Pi 4 ARM64
        working-directory: ${{ env.UBOOT_DIR }}
        run: |
          for f in ${{ github.workspace }}/smee/internal/firmware/patches/*.patch; do
            echo "Applying patch: $f"
            patch -p1 < "$f"
          done

          make CROSS_COMPILE=aarch64-linux-gnu- rpi_arm64_defconfig

      - name: Build U-Boot
        working-directory: ${{ env.UBOOT_DIR }}
        run: |
          make CROSS_COMPILE=aarch64-linux-gnu- -j $(nproc) HOSTLDLIBS_mkimage="-lssl -lcrypto"
          ls -la u-boot.bin

      - name: Download Raspberry Pi firmware
        run: |
          mkdir -p ${{ env.BUILD_DIR }}
          cd ${{ env.BUILD_DIR }}
          
          echo "Downloading Raspberry Pi firmware version ${{ env.RPI_FIRMWARE_VERSION }}"
          wget -O raspi-firmware.tar.xz \
            "https://github.com/raspberrypi/firmware/releases/download/${RPI_FIRMWARE_VERSION}/raspi-firmware_${RPI_FIRMWARE_VERSION}.orig.tar.xz"
          
          echo "Extracting firmware..."
          tar -xf raspi-firmware.tar.xz
          ls -la

      - name: Create custom config.txt
        run: |
          mkdir -p ${{ env.BUILD_DIR }}/boot
          
          cat > ${{ env.BUILD_DIR }}/boot/config.txt << 'EOF'
          # U-Boot Configuration for Raspberry Pi 4
          # Enable 64-bit mode
          arm_64bit=1
          
          # Use U-Boot instead of kernel
          kernel=u-boot.bin
          
          # Enable UART for debugging
          enable_uart=1
          
          # GPU memory (minimal since this is for netboot)
          gpu_mem=16
          
          # Disable rainbow splash
          disable_splash=1
          
          # Network boot configuration
          # Enable PXE boot
          [pi4]
          # Ensure USB is enabled for boot
          max_usb_current=1
          
          # HDMI settings for display output
          hdmi_force_hotplug=1
          
          # Device tree overlays
          dtparam=audio=off
          
          # Enable USB boot
          program_usb_boot_mode=1
          EOF

      - name: Prepare boot directory
        run: |
          cd ${{ env.BUILD_DIR }}
          
          # Find the extracted firmware directory
          FIRMWARE_DIR=$(find . -maxdepth 1 -type d -name "raspi-firmware-*" | head -n 1)
          echo "Firmware directory: $FIRMWARE_DIR"
          
          # Copy boot files from firmware
          if [ -d "$FIRMWARE_DIR/boot" ]; then
            cp -v "$FIRMWARE_DIR"/boot/*.bin boot/ 2>/dev/null || true
            cp -v "$FIRMWARE_DIR"/boot/*.dat boot/ 2>/dev/null || true
            cp -v "$FIRMWARE_DIR"/boot/*.elf boot/ 2>/dev/null || true
            cp -v "$FIRMWARE_DIR"/boot/*.dtb boot/ 2>/dev/null || true
            cp -rv "$FIRMWARE_DIR"/boot/overlays boot/ 2>/dev/null || true
          fi
          
          # Copy U-Boot binary
          cp ${{ env.UBOOT_DIR }}/u-boot.bin boot/
          
          echo "Boot directory contents:"
          ls -lah boot/

      - name: Create SD card image
        id: create_image
        run: |
          cd ${{ env.BUILD_DIR }}
          
          # Calculate required size (boot files + 100MB padding)
          BOOT_SIZE=$(du -sm boot | cut -f1)
          IMAGE_SIZE=$((BOOT_SIZE + 100))
          
          echo "Creating ${IMAGE_SIZE}MB image..."
          
          # Create image file
          IMAGE_NAME="rpi4-uboot-${UBOOT_VERSION}-firmware-${RPI_FIRMWARE_VERSION}.img"
          dd if=/dev/zero of="$IMAGE_NAME" bs=1M count=$IMAGE_SIZE status=progress
          
          # Create partition table
          parted "$IMAGE_NAME" --script mklabel msdos
          parted "$IMAGE_NAME" --script mkpart primary fat32 1MiB 100%
          parted "$IMAGE_NAME" --script set 1 boot on
          
          # Setup loop device
          LOOP_DEVICE=$(sudo losetup --find --show --partscan "$IMAGE_NAME")
          echo "Loop device: $LOOP_DEVICE"
          
          # Format partition
          sudo mkfs.vfat -F 32 -n BOOT "${LOOP_DEVICE}p1"
          
          # Mount and copy files
          mkdir -p mnt
          sudo mount "${LOOP_DEVICE}p1" mnt
          sudo cp -rv boot/* mnt/
          sudo sync
          sudo umount mnt
          
          # Cleanup
          sudo losetup -d "$LOOP_DEVICE"
          
          # Calculate checksums
          sha256sum "$IMAGE_NAME" > "${IMAGE_NAME}.sha256"
          
          # Get image info
          IMAGE_SIZE_BYTES=$(stat -c%s "$IMAGE_NAME")
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "image_size=$IMAGE_SIZE_BYTES" >> $GITHUB_OUTPUT
          
          ls -lh "$IMAGE_NAME"*

      - name: Compress image
        run: |
          cd ${{ env.BUILD_DIR }}
          IMAGE_NAME="${{ steps.create_image.outputs.image_name }}"
          
          echo "Compressing image..."
          xz -9 -T 0 "$IMAGE_NAME"
          
          # Update checksum for compressed file
          sha256sum "${IMAGE_NAME}.xz" > "${IMAGE_NAME}.xz.sha256"

      - name: Create release notes
        id: release_notes
        run: |
          cat > release_notes.md << EOF
          # Raspberry Pi 4 U-Boot SD Card Image
          
          ## 📦 Components
          
          - **U-Boot Version**: \`${{ env.UBOOT_VERSION }}\`
          - **Raspberry Pi Firmware**: \`${{ env.RPI_FIRMWARE_VERSION }}\`
          - **Architecture**: ARM64 (aarch64)
          - **Target Device**: Raspberry Pi 4 / Raspberry Pi 400
          
          ## 🚀 Features
          
          - ✅ PXE network boot support
          - ✅ DHCP client built-in
          - ✅ EFI boot support
          - ✅ USB storage boot
          - ✅ NVMe boot support (with patches)
          - ✅ Custom boot command for network-first boot
          
          ## 📥 Installation
          
          ### Using Raspberry Pi Imager
          
          1. Download \`${{ steps.create_image.outputs.image_name }}.xz\`
          2. Open Raspberry Pi Imager
          3. Choose "Use custom" and select the downloaded \`.xz\` file
          4. Select your SD card
          5. Write the image
          
          ### Using dd (Linux/macOS)
          
          \`\`\`bash
          # Decompress
          xz -d ${{ steps.create_image.outputs.image_name }}.xz
          
          # Write to SD card (replace /dev/sdX with your SD card device)
          sudo dd if=${{ steps.create_image.outputs.image_name }} of=/dev/sdX bs=4M status=progress
          sudo sync
          \`\`\`
          
          ## ⚙️ Boot Configuration
          
          The image includes a custom \`config.txt\` that:
          - Enables 64-bit ARM mode
          - Uses U-Boot as the kernel
          - Configures minimal GPU memory
          - Enables UART for debugging
          
          ## 🔧 Boot Command
          
          The default boot sequence:
          1. Attempt USB disk boot (EFI)
          2. Attempt network boot via DHCP/PXE
          3. Fall back to local disk
          
          ## ✅ Verification
          
          Verify the image integrity:
          
          \`\`\`bash
          sha256sum -c ${{ steps.create_image.outputs.image_name }}.xz.sha256
          \`\`\`
          
          ## 📊 Image Information
          
          - **Uncompressed Size**: ${{ steps.create_image.outputs.image_size }} bytes
          - **Format**: Raw disk image (MBR partition table, FAT32 boot partition)
          
          ---
          
          *Built on $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF
          
          cat release_notes.md

      - name: Create GitHub Release
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/uboot-v')
        uses: softprops/action-gh-release@v1
        with:
          body_path: release_notes.md
          files: |
            ${{ env.BUILD_DIR }}/${{ steps.create_image.outputs.image_name }}.xz
            ${{ env.BUILD_DIR }}/${{ steps.create_image.outputs.image_name }}.xz.sha256
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts
        if: github.event_name != 'push'
        uses: actions/upload-artifact@v4
        with:
          name: rpi4-uboot-image
          path: |
            ${{ env.BUILD_DIR }}/${{ steps.create_image.outputs.image_name }}.xz
            ${{ env.BUILD_DIR }}/${{ steps.create_image.outputs.image_name }}.xz.sha256
            release_notes.md
          retention-days: 30

      - name: Report build status
        run: |
          echo "✅ U-Boot SD card image created successfully"
          echo "� Image: ${{ steps.create_image.outputs.image_name }}.xz"
          echo "📏 Uncompressed size: ${{ steps.create_image.outputs.image_size }} bytes"
          echo "🔖 U-Boot version: ${{ env.UBOOT_VERSION }}"
          echo "🔖 Firmware version: ${{ env.RPI_FIRMWARE_VERSION }}"
